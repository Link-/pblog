---
layout: post
title:  "A1. Fundamentals not Ornaments"
date:   2020-05-30 13:29:01 +0200
categories: book chapter a1
sitemap:
  exclude: 'yes'
---
The Dirty Past
==============

Sometimes I still recall the pungent smell of plastic and [Pentium CPUs](https://en.wikipedia.org/wiki/Pentium) toiling away in the neon white lit computer lab at school. I was about 10 or 11 years old when I was first allowed to touch a desktop computer. It was part of our weekly 1-hour computer lab session. Even though I had only seen these machines from the window of the lab as we walked past it on our way to other classes, for some weird reason I couldn’t contain my excitement and impatience to discover these magnificent calculators on our first lab session. We entered through the door in a queue one student at a time.

<img class="s t u ig ai" src="https://miro.medium.com/max/356/1\*RzhNCIS-8S2UpC8ct8imjQ.png" width="178" height="66" role="presentation"/>

MS-DOS 6.22 booting, from QEMU. Image created by [Mike Swanson](https://en.wikipedia.org/wiki/User:MikeRS). MS-DOS © 1994 Microsoft.

We took our seats in front of [15inch beige](https://www.ebay.com/itm/Computer-Monitor-15-Fujitsu-Siemens-151E/173710549203?hash=item2871f4a0d3:g:5WMAAOSwcttcJPbL) [cathode ray tube monitors](https://en.wikipedia.org/wiki/Cathode-ray_tube) and a strong thrill took hold of me as I stared into the black terminal with the blinking underscore cursor. **I fell in love.**

I was quite curious as a kid, it didn’t take long to conquer these beasts. Taming them was the next logical step. For the following nine years I taught myself how to program (or so I thought).

<img class="s t u ig ai" src="https://miro.medium.com/max/1270/1\*kdTcu4vOAewPD3eYNeyx6g.jpeg" width="635" height="480" srcSet="https://miro.medium.com/max/552/1\*kdTcu4vOAewPD3eYNeyx6g.jpeg 276w, https://miro.medium.com/max/1000/1\*kdTcu4vOAewPD3eYNeyx6g.jpeg 500w" sizes="500px" role="presentation"/>

3 1⁄2 inch floppy disks — by Victor Korniyenko — Own work, CC BY 3.0, [https://commons.wikimedia.org/w/index.php?curid=10682229](https://commons.wikimedia.org/w/index.php?curid=10682229)

In the early 2000s, learning resources and internet access at home were a luxury. Add to that the fact that my parents thought computers were a waste of time and that I should focus only on my school’s curriculum, my progress was slow. Typical reaction of concerned parents who didn’t know anything about the field. Technology was not as ubiquitous as it is today.

My only access to the internet was for a couple of hours on Friday evenings at the local internet café. My jeans’ back pockets were filled with a dozen 3 and a 1⁄2 inch floppy disks with a storage capacity of 1.44MBs each. My Internet browsing was quick and efficient. I used to skim through the online articles and capitalize on my previous week’s learning to search for the missing pieces of the puzzle of whatever topic I was studying. I used to download the HTML files of the articles I could find and store them on the disks. Studying them at home was far better than wasting precious time online.

Limited internet access taught me to appreciate my time online and to minimize waste. **Scarcity teaches creativity** (remember this, we will come back to it later).

**The projects and the code I wrote back then were as dirty as code can get.** They were horrendously written by any standard. Cringe-worthy coding style, and gaping logic. The only thing DRY (Do not Repeat Yourself) in that code was my problem solving well. Understandable maybe(?) given that my sole concern was for the code to run and behave as I desired.

To give you an idea of what I’m referring to, imagine implementing Tic Tac Toe with hundreds of nested conditionals to cover all possible scenarios. I’ll give you a moment to absorb how horrible that is.

Up to this point, I had learned a bit of C, some Visual Basic, some HTML and later a little bit of PHP, Javascript, Linux (SUSE Linux) and bash scripting. My ego had skyrocketed, I thought of myself a prodigy. Little did I know, I was far from it. **A reality check was necessary.**

The Discovery of Style and Elegance
===================================

Fast forward to my sophomore year at University studying Computer Science. I ventured into my intro to programming course, head held high, pitying my poor classmates — the majority of whom had never written a single line of code in their lives. “Who knows a programming language or has ever written some code before?”, our professor asked. I turned in all directions trying to spot if anyone raised their hand. No one did. Feeling a deep sense of pride I raised mine: “I know C, VB, HTML, and PHP”, I said. The professor looks at me, puts on a smirk, and goes on to start his lecture.

I didn’t understand what had just happened. Why isn’t anyone praising me for my achievement? Obviously, I was intellectually superior to everyone else. Why isn’t this snobbish professor lauding my skills? Where was this praise that I (thought I) deserved? Little did I know, I was nowhere near as _special_ as I had hoped I would be. Turns out, at the beginning of every semester, specifically in this class there was always **this student boasting about how** **they didn’t need a University education, how they knew it all but that’s just how the world works so they’re here to entertain the system.** Sounds familiar?

The second question that came out of **my professor** **put me right where I belonged**. “What is floating point precision?”, he asked. I had no clue what he was referring to. I was shocked and embarrassed.

Slowly but surely **I climbed down from my ivory tower**. And right then and there **began the process of refining whatever raw, and disconnected information I had collected over the years, as an amateur, into knowledge that is at the foundation of everything I do today as a professional.**

When I was first exposed to Object-Oriented Programming I gasped. I can do that? And that?! For the first time, **I developed a sense of appreciation for the stylistic aspect of coding.** Then I was introduced to Data Structures (LinkedLists, Stacks, Queues, BSTs, HashMaps, Graphs etc.) I was in awe! The thought of how little I knew about this field shook me like a tree on a stormy night. Later I discovered algorithms (Complexity Analysis, Sorting, Searching, Graph Traversal, Recursion etc.). **At this stage, I was like a blind person who was seeing for the first time, ever.** This is when I understood that **“elegance” is a property of code and algorithms**. That **coding for its own sake is useless, that coding is a problem-solving tool and that making code work is not the only point.**

Fundamentals vs Ornaments
=========================

It took me years to shake the **insolence of the youth**. To **mature as an individual** was a painful process for myself and more so for my mentors. _If you’re reading this, do not follow my lead._ **Humility is indispensable.** **Learn it early, and learn it fast. It will serve you well.**

On a busy Monday afternoon, I was visiting one of my professors and we were discussing my academic performance. He pointed out a few areas where I should do better. I quickly jumped to my defense by, once again, enumerating a list of languages I had learned — as if the purpose of Computer Scientists is memorizing syntax and knowing the largest number of languages possible. He patiently nodded and said:

> **“Our purpose, as educators, is not to graduate technicians but well-rounded professionals who will positively contribute to society and to the advancement of our field.”**

I was silent. His message resonated so well, it was sort of like putting the last piece of a jigsaw puzzle and seeing the entire picture. **I didn’t want to the one who can only change a lightbulb, I wanted to be the one who understood how it worked, and if needed be able to design and build one**.

Over the years, I internalised that message further. **Add to that the fact that there is much to learn that it’s impossible for a person to master everything in one lifetime.** _(Learn to accept this fact)_

As such, **I define the following 2 categories** that you can use to understand what you should prioritise in your learning journey:

Fundamentals
------------

> **Fundamentals refer to the assemblage of topics that constitute a scientific field and to the time tried and tested methods and technologies. Fundamentals are the cornerstone of a solid Software Engineering career.**

**Topics:** These topics are not opinions, not a rehash of older notions in different packaging, not necessarily applied, possibly highly abstract generalizations, and most definitely timeless truths.

**Technologies:** Fundamentals also refer to the array of technologies and tools that have stood the test of time. Tools used in small and large implementations. Tools that have scaled well and have demonstrable stability.

**Methods:** Lastly,  Fundamentals refer to the methods of developing software that have proven to be effective in yielding _desired outcomes (a broad term defined in following articles)_.

**Examples (not limited to):**

> For a curated list of material and online courses (some are paid, some are free) to augment your knowledge of the topics refer to **the Learning References** section at the bottom of this article. **Not all courses are introductory.**

\[ Topic \] **Algorithms and Data Structures:** If you haven’t covered these topics at all, it’s imperative that you do so the soonest possible. I’ve written extensively about [the importance of Algorithms and Data Structures](https://medium.com/swlh/algorithms-complexity-analysis-and-data-structures-matter-9ed0b93ea3b7) it’d be redundant to write about it again here.

\[ Topic \] **Calculus, Statistics, Discrete Mathematics, and Linear Algebra:** Someday you’re going to need to read a paper to implement some algorithm, or you decide that it became necessary to learn Machine Learning, or you’re requested to do some data analysis and generate a statistical report or … The list goes on. When that time comes, you’ll regret not developing a good understanding of these topics. Hacking your way only takes you so far. Sooner or later you’re going to need to work on a problem that no one has solved before and these topics will come in handy.

\[ Topic \] **Computer Architecture**

\[ Topic \] **Programming Language Theory and Compiler Construction**

\[ Topic \] **Operating Systems**

\[ Topic \] **The** [**relational model**](https://en.wikipedia.org/wiki/Relational_model) of data as proposed by [E. F. Codd](https://en.wikipedia.org/wiki/E._F._Codd) in 1970 and as a follow-up master at least one Relational Database

\[ Technology \] **Diversification of Language Paradigms Knowledge:** The majority of software engineers I know have developed a good understanding of imperative, procedural, object-oriented and declarative languages. A minority ventures to learn functional, symbolic, logical and mathematical languages. It’s necessary for you to develop your skills in different paradigms. This will allow you to explore different ways to solve problems.

\[ Technology \] **Virtual Machines**

\[ Technology \] **Relational Databases**

\[Method\] **Refactoring Patterns:** “Refactoring is a change made to the internal structure of software to make it easier to understand and cheaper to modify without changing the observable behavior” ²

\[ Method \] **Testing Automation:** Martin Fowler in his article [The Practical Test Pyramid](https://martinfowler.com/articles/practical-test-pyramid.html) does a fantastic job explaining the importance of testing automation, I’m definitely not going to do a better job. **Read the whole thing** but here’s the gist of it for the impatient:

> Software has become an essential part of the world we live in \[…\] The wheels of innovation are turning faster \[…\] If you want to keep pace you’ll have to look into ways to deliver your software faster without sacrificing its quality \[…\] Building, testing and deploying an ever-increasing amount of software manually soon becomes impossible \[…\] Luckily there’s a remedy for repetitive tasks: _automation_. \[…\] Automate your tests and you can change your codebase without batting an eye…

\[ Method and Technology \] **Source Control:** If you’re not using a Source Code Management (SCM)— also known as Version Control System (VCS) or Revision Control System (RCS) — during software development, STOP. **Please, please, please learn how to use one and integrate it into your development process.** This is one of the most critical skills to develop if you want to collaborate with a team. If you don’t know how to use one within a team context your chances of landing a job are drastically reduced. I’m not going to dictate which flavor is best (ehm, use [git](https://git-scm.com/)) **anything is better than not using an SCM.**

\[ Method \] [**Object-Oriented Programming Design Patterns**](https://en.wikipedia.org/wiki/Software_design_pattern)**:** I cannot emphasize how important learning about design patterns is. Do not make the mistake of thinking they’re a silver bullet. **They’re best studied after having built a number of projects** using a language that supports OOP **in order to truly appreciate where, when and how they can be effectively applied.**

\[ Method \] [**n-tier Architecture**](https://en.wikipedia.org/wiki/Multitier_architecture)**:** client-server architecture in which presentation, application processing, and data management functions are physically separated. I’ve worked with many fresh graduates who didn’t appreciate the importance of this architecture. You need to be able to look at your projects from an architectural perspective and not just the details of the implementation. You also need to be able to define where each piece of the project needs to go to obtain better results (lower maintenance cost, higher availability, better decoupling etc. We will cover all those in subsequent articles.)

Ornaments
---------

> **Ornaments refer to a temporarily popular application and/or repackaging of an aspect of a fundamental topic or subtopic under a new brand name. Ornaments alone are not a sufficient foundation for a solid Software Engineering career.**

In other words, much of the popular tools that are evangelized today as silver bullets are to some extent a re-implementation of a formally defined topic/subtopic or a branch of Computer Science (most likely in the 60s, 70s, 80s, and 90s) or a repackaging of a different tool under new branding. Rare are the tools, popularized today, that are a byproduct of a recent advancement or a breakthrough in Computer Science.

**Focusing on learning the Ornaments before covering the Fundamentals is a mistake.**

Many will argue that it is possible to take on a lucrative job in one of the items listed below. That is true, it’s possible. But, I will bet you 100 USD that **at some point in the future that same person will be asked or forced to go back to the fundamentals in order to make career progress or solve a particular problem.** It’s inevitable.

Think of ornaments as the decoration for your trusted foundational knowledge.

**Examples (not limited to):**

**NoSQL databases:** Such databases have existed since the late 1960s, but did not obtain the “NoSQL” moniker until a surge of popularity in the early twenty-first century¹

**Trendy Programming Languages:** “But [Node.js](https://nodejs.org/en/) is super duper fast because it’s async.” **“**Should I learn Javascript or [Ruby](https://www.ruby-lang.org/en/)?” “I heard [PHP](http://php.net/) is dead.” “Google is using [Python](https://www.python.org/).” “Is it safe to use [Kotlin](https://kotlinlang.org/)?” “[Swift](https://swift.org/) is THE BEST thing ever.” “[Go](https://golang.org/) and [Rust](https://www.rust-lang.org/) are on my bucket list for this year.” If that’s you, worry not, we’ve all been there. Learning new languages offers us the ability to stay competitive in the market, and fighting over which language is better is fun. But it’s all fun and games until you fall into the trap of being a syntax learner who cares about the number of languages she knows as **opposed to mastering her tools.** Don’t be that person. Mastering a single language will allow you to learn others at a faster rate, at will, and at an increased depth.

**Front-End Frameworks:** If you’re confused about whether you should learn [Angular](https://angular.io/) or [React.js](https://reactjs.org/) w [Redux](https://redux.js.org/) or [Vue.js](https://vuejs.org/) maybe even [Backbone.js](http://backbonejs.org/) or <insert name here>.js, that’s due to the explosion of opinions and the rising complexity of building apps for the web or single page apps (SPAs). Don’t worry, you’re not alone, the majority of the developers’ community is going through the same confusion. Front-end frameworks are awesome (I’m serious). Just pick one and learn it that’s the only sensible way to start.

**Back-End Frameworks:** The same pitfalls of trendy languages and front-end frameworks apply to back-end frameworks. **Just pick one.**

**Machine Learning:** No you won’t be able to build your own [C3PO](https://en.wikipedia.org/wiki/C-3PO) just yet. Sorry to burst your bubble. Machine Learning has little to do with [Artificial General Intelligence](https://en.wikipedia.org/wiki/Artificial_general_intelligence). The field is not new, you’re hearing about it often because it’s currently at the Peak of Inflated Expectations (refer to the next section). ML is a great tool that has a vast array of applications. Today there’s a huge demand for Software Engineers with ML experience. However, don’t fool yourself into thinking you can go far in the field without covering your fundamentals. Especially if you wish to understand what’s happening under the hood.

The list goes on: **Microservices and Serverless Architectures, Container Technology and Kubernetes, Blockchain, Chatbots, …**

Gartner’s Hype Cycle³
=====================

The first time I saw [Gartner’s chart](https://www.gartner.com/en/research/methodologies/gartner-hype-cycle) I thought to myself: what is this sorcery?! Around the same time, I was thinking a lot about how many technologies rise to global popularity only to fizzle out shortly afterward. **The pattern was so powerful. Yet, it wasn’t visual until I’ve seen this**:

<img class="s t u ig ai" src="https://miro.medium.com/max/2184/1\*FT9ZSAYqxMxvnk95YHvmSw.jpeg" width="1092" height="727" srcSet="https://miro.medium.com/max/552/1\*FT9ZSAYqxMxvnk95YHvmSw.jpeg 276w, https://miro.medium.com/max/1104/1\*FT9ZSAYqxMxvnk95YHvmSw.jpeg 552w, https://miro.medium.com/max/1280/1\*FT9ZSAYqxMxvnk95YHvmSw.jpeg 640w, https://miro.medium.com/max/1400/1\*FT9ZSAYqxMxvnk95YHvmSw.jpeg 700w" sizes="700px" role="presentation"/>

Interpreting technology hype — Gartner Hype Cycle [https://www.gartner.com/en/research/methodologies/gartner-hype-cycle](https://www.gartner.com/en/research/methodologies/gartner-hype-cycle)

> When new technologies make bold promises, how do you discern the hype from what’s commercially viable? And when will such claims pay off, if at all? Gartner Hype Cycles provide a graphic representation of the maturity and adoption of technologies and applications, and how they are potentially relevant to solving real business problems and exploiting new opportunities. Gartner Hype Cycle methodology gives you a view of how a technology or application will evolve over time, providing a sound source of insight to manage its deployment within the context of your specific business goals.

I’m definitely not evangelizing Gartner’s research nor promoting it. But, credit is due where credit is due. **Their analysis of technologies and where they fall onto the curve is at the very minimum interesting to review.** You're definitely not encouraged to base your decisions solely on Gartner’s reports.

Have a look at 2018’s hype cycle for _Emerging Technologies_:

<img class="s t u ig ai" src="https://miro.medium.com/max/3002/1\*Fs2DBxDA2rx-5NtN7q\_yuw.png" width="1501" height="1269" srcSet="https://miro.medium.com/max/552/1\*Fs2DBxDA2rx-5NtN7q\_yuw.png 276w, https://miro.medium.com/max/1104/1\*Fs2DBxDA2rx-5NtN7q\_yuw.png 552w, https://miro.medium.com/max/1280/1\*Fs2DBxDA2rx-5NtN7q\_yuw.png 640w, https://miro.medium.com/max/1456/1\*Fs2DBxDA2rx-5NtN7q\_yuw.png 728w, https://miro.medium.com/max/1632/1\*Fs2DBxDA2rx-5NtN7q\_yuw.png 816w, https://miro.medium.com/max/1808/1\*Fs2DBxDA2rx-5NtN7q\_yuw.png 904w, https://miro.medium.com/max/1984/1\*Fs2DBxDA2rx-5NtN7q\_yuw.png 992w, https://miro.medium.com/max/2000/1\*Fs2DBxDA2rx-5NtN7q\_yuw.png 1000w" sizes="1000px" role="presentation"/>

5 Trends Emerge in the Gartner Hype Cycle for Emerging Technologies, 2018 — [https://www.gartner.com/smarterwithgartner/5-trends-emerge-in-gartner-hype-cycle-for-emerging-technologies-2018/](https://www.gartner.com/smarterwithgartner/5-trends-emerge-in-gartner-hype-cycle-for-emerging-technologies-2018/)

The question I want you to always think about when exploring a new technology:

**Where does this technology lie on the Hype Curve?**

Its position is usually a hint of whether you need to prioritize exploring it or shelving it for a while.

Career Investment Strategy
==========================

When to Learn What?
-------------------

I’m a strong believer in the necessity of abolishing discipline borders. The breadth and depth of fields and topics have forced us all into bottomless specialization pits. This follows from the fact that it’s impossible for a person to master everything in one lifetime.

As an example of cross-disciplinary ideation, I’d like to apply the fundamentals of finance and investment strategies to career building.

In finance, devising a healthy investment strategy is a crucial aspect of raising a fortune, building a retirement plan, or simply saving for a rainy day. The worst thing you can do is to spend all your income. Less bad is storing your cash under the mattress. Putting your money into a savings account with compound interest is the beginning of a healthy investment strategy.

It all starts with a goal. What do you want to achieve in the next 10 to 15 years? This is definitely not a question to answer when you’ve only had 1 or 2 years of industry experience. Nevertheless, it’s essential to answer that question the further you progress. Without some direction, you’ll be completely at the mercy of the conspiring Universe and utter luck.

Plans are bound to fail, [Nassim Taleb](https://en.wikipedia.org/wiki/Nassim_Nicholas_Taleb) has written 3 books regurgitating this exact idea. Nevertheless, you’re always better off knowing exactly where you are in the world and identifying the variables and circumstances at play. You might not be able to fend off all the bad things but at least you’ll be better prepared.

**To make the analogy more concrete, think of learning as your investment tool. It’s your trading platform. The topics to learn are your bonds and stocks. Your long-term career goals are your investment strategy.**

<img class="s t u ig ai" src="https://miro.medium.com/max/2184/1\*2fuKcOKOvcKrTqwDN4VVgA.jpeg" width="1092" height="727" srcSet="https://miro.medium.com/max/552/1\*2fuKcOKOvcKrTqwDN4VVgA.jpeg 276w, https://miro.medium.com/max/1104/1\*2fuKcOKOvcKrTqwDN4VVgA.jpeg 552w, https://miro.medium.com/max/1280/1\*2fuKcOKOvcKrTqwDN4VVgA.jpeg 640w, https://miro.medium.com/max/1400/1\*2fuKcOKOvcKrTqwDN4VVgA.jpeg 700w" sizes="700px" role="presentation"/>

Areas you should focus on with every Industry Experience bracket

**Industry Experience ≤ 5 years**
---------------------------------

During this period you need to invest as much time as possible in **filling the gaps in your Fundamentals** (refer to the previous section). **This is the period during which you build a strong foundation on top of which you will build your entire future career.** As cliché as it sounds, having a weak foundation is a recipe for a flimsy career and in return volatile financial stability down the road.

This is not the time to be on the cutting edge. That comes later. **No matter how tempting it is to learn the technologies that are ascending from the Innovation Trigger towards the peak you need to resist that urge and focus.** You have absolutely nothing to contribute to the conversation, the research or the innovation and creation processes. Remember we’re talking about you as a Software Engineer not a researcher following an academic track.

If you feel that you’re **ahead of the curve on the fundamentals, you can choose 1 or 2 topics at best that are on the Plateau of Productivity** to invest in and upgrade your status.

**Industry Experience > 5 and ≤ 10 years**
------------------------------------------

During this period you should have a **good grip on your fundamentals to a point where you should feel comfortable using and applying much of the concepts on a need basis.** Googling things is not cheating. That’s OK.

**This is the perfect time to make long-term investments.** When technologies are on the way down to the Trough of Disillusionment the mainstream hype associated with them starts fading. This is when the true believers in a certain technology and usually the insiders who are able to discern the bullshit from the true value start preparing for stability.

**Place your bets on an area you’re passionate about and contribute to the conversation and or the building process.** Promote your work and start establishing yourself as a domain expert. **When the technology steadily climbs back towards the Plateau of Productivity you will then be able to reap the benefits of your investment.**

Industry Experience > 10 years
------------------------------

So much learning has happened in the past 10 years of your career. **This is the ideal time to start giving back and to make your voice heard.** During this phase the best form of investment you can make is moonshots.

Google X, now known as [X Development LLC](https://en.wikipedia.org/wiki/X_(company)), has coined the term moonshots which is “defined by X as the intersection of a big problem, a radical solution, and breakthrough technology.” ⁴

You should be quite aware of your areas of passion, if you aren’t, figure them out. Whether you like it or not you must have spent more time working on a certain topic than others. That might be back-end web development, mobile development, embedded systems, enterprise systems etc. You’ve accumulated experience and whether by luck or planning that experience is not public knowledge yet. **Make it public.**

If you don’t have that sort of experience, that’s ok, in fact, you’re probably part of the majority (myself included) of software engineers who have not had the opportunity to work on the _sexy_ problems. In this case, there are endless projects that are the in the seed stage that require contributors. **Pick one.** The only criteria are: **Follow your passion and Think Big.**

Summary
=======

*   Scarcity teaches creativity
*   University education was the process of refining whatever raw, and disconnected information I had collected over the years, as an amateur, into knowledge that is at the foundation of everything I do today as a professional.
*   Coding is a problem-solving tool and making code work is not the only point.
*   Humility is indispensable. Learn it early, and learn it fast. It will serve you well.
*   Fundamentals refer to the assemblage of topics that constitute a scientific field and to the time tried and tested methods and technologies. Fundamentals are the cornerstone of a solid Software Engineering career.
*   Ornaments refer to a temporarily popular application and/or repackaging of an aspect of a fundamental topic or subtopic under a new brand name. Ornaments alone are not a sufficient foundation for a solid Software Engineering career.
*   Focusing on learning the Ornaments before covering the Fundamentals is a mistake.
*   It is possible to accept a lucrative job in one of the ornaments but going back to the fundamentals in the future is inevitable.
*   The hype cycle is a powerful pattern and Gartner’s hype chart helps to visualize it.
*   Always ask yourself where does this technology lie on the Hype Curve to determine the priority of learning it.
*   Think of learning as your investment tool. It’s your trading platform. The topics to learn are your bonds and stocks. Your long-term career goals are your investment strategy.
*   Industry Experience ≤ 5 years: Fill the gaps in your Fundamentals.
*   Industry Experience > 5 and ≤ 10 years: The perfect time to make long-term investments.
*   Industry Experience > 10 years: The ideal time to start giving back and to make your voice heard. Follow your passion and Think Big.

* * *

**Acknowledgments**
-------------------

Thank you to [Hasan Hawash](https://medium.com/u/e77dc934431d?source=post_page-----94b6ebb68dba----------------------), Alaa El Hariri, [Rida Assaf](https://medium.com/u/9a8c5f5700be?source=post_page-----94b6ebb68dba----------------------) and [Nagham Al Halabi](https://medium.com/u/d4aedbe94365?source=post_page-----94b6ebb68dba----------------------) for reading drafts and contributing feedback for this article.

* * *

References
----------

\[1\] [https://en.wikipedia.org/wiki/NoSQL#cite\_note-leavitt-2](https://en.wikipedia.org/wiki/NoSQL#cite_note-leavitt-2)

\[2\] Refactoring First Edition p.53 — by M. Fowler

\[3\] [https://www.gartner.com/en/research/methodologies/gartner-hype-cycle](https://www.gartner.com/en/research/methodologies/gartner-hype-cycle)

\[4\] [https://en.wikipedia.org/wiki/X\_(company)#cite\_note-12](https://en.wikipedia.org/wiki/X_(company)#cite_note-12)

* * *

Learning References
-------------------

\[ Topic \] **Algorithms and Data Structures**

```
Learning Strategy:  
\------------------. Start with "Algorithms" by "R. Sedgewick & K. Wayne":  
[https://algs4.cs.princeton.edu/home/](https://algs4.cs.princeton.edu/home/). Supplement it with Analysis of Algorithms by R. Sedgewick:  
[https://www.coursera.org/learn/analysis-of-algorithms](https://www.coursera.org/learn/analysis-of-algorithms). Specialization:  
[https://www.coursera.org/specializations/algorithms](https://www.coursera.org/specializations/algorithms). Or others from:edX: [https://www.edx.org/](https://www.edx.org/)  
Coursera: [https://www.coursera.org](https://www.coursera.org)  
Udemy: [https://www.udemy.com/](https://www.udemy.com/)
```

\[ Topic \] **Calculus, Statistics, Discrete Mathematics, and Linear Algebra**

```
Introductory ecourse:  
\---------------------. Calculus: Single Variable Part 1 - Functions  
[https://www.coursera.org/learn/single-variable-calculus](https://www.coursera.org/learn/single-variable-calculus). Calculus: Single Variable Part 2 - Differentiation  
[https://www.coursera.org/learn/differentiation-calculus](https://www.coursera.org/learn/differentiation-calculus). Calculus: Single Variable Part 3 - Integration  
[https://www.coursera.org/learn/integration-calculus](https://www.coursera.org/learn/integration-calculus). Calculus: Single Variable Part 4 - Applications  
[https://www.coursera.org/learn/applications-calculus](https://www.coursera.org/learn/applications-calculus). Statistics with R  
[https://www.coursera.org/specializations/statistics](https://www.coursera.org/specializations/statistics)TK
```

\[ Topic \] **Computer Architecture**

```
Supplementary e-course:  
\-----------------------. Build a Modern Computer from First Principles: From Nand to Tetris (Project-Centered Course) \[Part I\]  
[https://www.coursera.org/learn/build-a-computer](https://www.coursera.org/learn/build-a-computer). Build a Modern Computer from First Principles: From Nand to Tetris (Project-Centered Course) \[Part II\]  
[https://www.coursera.org/learn/nand2tetris2](https://www.coursera.org/learn/nand2tetris2)
```

\[ Topic \] **Programming Language Theory and Compiler Construction**

```
Supplementary ebook:  
\--------------------. Crafting Interpreters A handbook for making programming languages  
[https://craftinginterpreters.com/](https://craftinginterpreters.com/)
```

\[ Topic \] **Operating Systems**

```
Introductory ecourse:  
\---------------------. Introduction to Linux  
[https://www.edx.org/course/introduction-to-linux](https://www.edx.org/course/introduction-to-linux)
```

\[ Topic \] **The** [**relational model**](https://en.wikipedia.org/wiki/Relational_model) of data as proposed by [E. F. Codd](https://en.wikipedia.org/wiki/E._F._Codd) in 1970

```
Learning Platforms:  
\------------------. edX: [https://www.edx.org/](https://www.edx.org/)  
. Coursera: [https://www.coursera.org](https://www.coursera.org)
```

\[ Technology \] **Virtual Machines**

```
\[Free | Cross-platform\] VirtualBox  
[https://www.virtualbox.org/](https://www.virtualbox.org/)\[Paid | Cross-platform\] VMWare  
[https://www.vmware.com/](https://www.vmware.com/)\[Integrated | Windows\] Hyper-V  
[https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/quick-start/enable-hyper-v](https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/quick-start/enable-hyper-v)
```

\[ Technology \] **Relational Databases**

```
\[Free | Cross-Platform\] PostgreSQL  
[https://www.postgresql.org/](https://www.postgresql.org/)\[Free | Cross-Platform\] MariaDB  
[https://mariadb.org/](https://mariadb.org/)\[Free | Cross-Platform\] MySQL  
[https://www.mysql.com/](https://www.mysql.com/)\[Enterprise | Corss-Platform\] Oracle  
[https://www.oracle.com/database/](https://www.oracle.com/database/)
```

\[Method\] **Refactoring Patterns**

```
Best Resource:  
\--------------The second edition of "Refactoring" by Martin Fowler:[  
https://martinfowler.com/articles/refactoring-2nd-ed.html](https://martinfowler.com/articles/refactoring-2nd-ed.html)
```

\[ Method \] **Testing Automation**

```
. Start with Martin Fowler's article on the practical test pyramid:  
[https://martinfowler.com/articles/practical-test-pyramid.html](https://martinfowler.com/articles/practical-test-pyramid.html). Supplement it with the documentation for the testing frameworks you wish to useTK
```

\[ Method and Technology \] **Source Control**

```
. Start with "Version Control with Git" by Jon Loeliger  
[http://shop.oreilly.com/product/0636920022862.do](http://shop.oreilly.com/product/0636920022862.do). Supplement it with:  
[https://www.youtube.com/watch?v=SWYqp7iY\_Tc](https://www.youtube.com/watch?v=SWYqp7iY_Tc&t=1s). Supplement it with:  
[https://learngitbranching.js.org/](https://learngitbranching.js.org/)
```

\[ Method \] [**Object-Oriented Programming Design Patterns**](https://en.wikipedia.org/wiki/Software_design_pattern)

```
Learning Strategy:  
\------------------. Start with "Head First Design Patterns":  
[https://www.oreilly.com/library/view/head-first-design/0596007124/](https://www.oreilly.com/library/view/head-first-design/0596007124/). Supplement it with:  
[https://github.com/kamranahmedse/design-patterns-for-humans](https://github.com/kamranahmedse/design-patterns-for-humans). Complete the effort with "Design Patterns: Elements of Reusable Object-Oriented Software":  
[https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612](https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612)
```

\[ Method \] [**n-tier Architecture**](https://en.wikipedia.org/wiki/Multitier_architecture)
